$Header$

- mhooks must be stack-aware
- maybe with -I to ocamlmktop, we don't need the dirs in ocamlinit?????
  that would be great to automate from makefile
- why l3_bcast_addr is a special int, and l2_bcast is a variant type?
- convert hello_agent to inherit form rt_base, etc
- MACs without ACK should silently drop a packet to non-neighbor node, rather
  than complain.

- a bit odd to have both mac_recv_l{2,3}_pkt in agents, no?
  in a way do we expect that an agent *has* to only implement one?
  should we put default null methods in rt_agent_base???
  
- magic_bler_agent: merge into GREASE??
- note: in rewriting , reorging lots of stuff, never sure whether should have
  explicit class type, just a .mli with the class (but not the type), etc.
  maybe emerging "rule" is to only have class types for things which have
  multiple implementations (world, agent, mac, etc).

- taurus:
  what needs to change?
  a) Crworld methods from world.mli:
     world.boundarize
     world.dist_coords
     world.are_neighbors

     Crworld 'internal' methods:
     grid_neighbors_ 
     get_nodes_in_ring  ** 


  b) Crsearch.xsect_grid_and_circle **
    

  c) Mobility processes

  ** these are only used when calling 'find_closest_node' - so should be able
     to first do the rest, and test in grep.



- make all target:
  have a target that builds all scripts, so that we make sure not to break a
  the build for "old" scripts. 
  started doing this. need to figure out a clean way to build for all scripts
  in a list, rather than have to make an explicit target in teh makefile for
  each one.
  hand-tested diffusion_example.ml; doesn't work - need to revive
  make_gpsnodes in script_utils.ml, should probably find this in cvs.
	
- persistency: 
  not really figured out if restoring nodes should make us delete node objects,
  and then recreate them (along with any mob, mac, agent, .. objects; this would
  require a way to specify what such objects must be created for each node)
  or simply as currently.
  Decided to keep things as are for now. this is not a definite solution, but
  it makes more sense to try to come up with a full solution when i'll be
  faced with the need for it (and will thus better understand what the needs
  are).


- multiple traffic sources to multiple destinations (mentioned in
 simplenode.mli, but with XXX)
- consider the use of named function parameters. maybe going overboard with
 the ~s right now. maybe not, but at least need to be consistent.
 one criteria could be: 
 + when there is no .mli, and there are not multiple args of same type, then no
 need for ~ (properly naming the parameter is enough)
 + when there is a .mli, same as above, except that if parameter is of a generic
 type, (like int), then possible name the parameter.
 One the other hand, if parameter is say a L3pkt.t, then naming it ~l3pkt does
 not really help a lot.
 + when there are multiple parameters with same type, then definitely ~ helps.

- add copyright. not to heap, opt, and probably some others
/bin/sed-4.07  -i -e 's/(\*                                  \*)//g' simplenode.mli 
/bin/sed-4.07 -i  -e 's/(\* mws  multihop wireless simulator \*)//g' simplenode.mli 

- crworld.is_connected: 
  should be more efficient to originate one flood from one point, and see if
  everyone gets it. 
-  should clean up read_coords/epflcoords. 
   probably wait till a new dataset comes in (from michal?) and at that point,
   figure out the proper interfaces, abstractions, etc.

- mhooks : when you replace an array of agents with new ones, the old ones
  don't go away because they are still hooked in to their owners...
  one possibility would be to have add_*_hook methods return a handle (for
  example hooks are kept in a hash), and then a diff_Agent (or anyone else who
  has a handle) can have a detach() method which kills all its hooks before
  dying. 
  
- config: 
  val make_cmdline_able : 'a t -> unit
  val make_not_cmdline_able : 'a t -> unit

- creating nodes in script_utils
  there are going to be an increasing # of possible configurations, ie all 
  possible combinations of agents, MACs, etc.
  So instead of having one explicit function for each one (make_grease_nodes,
  make_grep_nodes, etc), we should have a more generic way of doing it.

  One possible solution:maybe a make_nodes(), then a make_*_agent which makes * type agents and adds
  them, similarly for macs, etc. Then we have a # of make funs which is linear
  in the # of different agents/macs/nodes rather than the comb. explosion of
  all combinations.

  Another possible solution: all these choosable things (which MAC, which
  diffusion algo, which routing agent) are settable by Params. Then there is
  only one "make_macs" which makes them based on what the Param value is.
  
- a big question is coming back all the time about how/where to access
  objects. For example, i make many hello_agents. Are these kept in an array
  in the same file as the hello_Agent class? in the script file? this impacts
  then routings like proportion_met_nodes(), etc..

- time printing in sched should use log. but this made a headache for circular
  dependency...

- neighbors: right now, seems like a node has itself as a neighbor. is this
  necessary? seems not. check well before changing...

- clean up mobility :
  granularity needs to be solidified. IF it is going to be used, then shoudl
  be tweakable. Also how does it relate to say random walk processes. Do they
  simply ignore it? Or do we distinguish between 'continuous' and 'discrete'
  classes?

  
- think about order in which mhooks is invoked. it can matter, in the case
  where agent code modifies packet. f. ex in ease_agent, if anchor changes in
  last hop, then we get:
  hop:<2865.353, 2561.326> 	anchor:<2970.990, 2469.370> 	age:8.000000 	cost:0.000000
  hop:<2918.412, 2582.598> 	anchor:<2970.990, 2469.370> 	age:8.000000 	cost:0.000000
  hop:<2989.889, 2587.548> 	anchor:<2970.990, 2469.370> 	age:8.000000 	cost:0.000000
  hop:<2949.183, 2459.140> 	anchor:<2951.178, 2434.621> 	age:0.000000 	cost:24.599721
  hop:<2951.178, 2434.621> 	anchor:<2951.178, 2434.621> 	age:0.000000 	cost:24.599721
  Fatal error: exception Failure("Searchcost was non-zero without anchor change")

- packets: better, but still somewhat unhappy with the type.
  maybe the union of all possible packet types forms a tree, and packet is a
  path through that tree (ie, a list of headers)?? might be better for typing.
  might make all these recursive operations (like *_clone, *_size) easier

  wishlist: 
  expressive typing:
  each packet type is fully 'expressed' in the type system, meaning that it
  has its fields and only its own. For example, a grep l3hdr should not be the
  same as an ease l3hdr
  'automatic' cloning and sizing : ideally clone and size operations could be
  recursively done on each packet type.

  get rid of mutable fields? or if we keep them, have a failsafe way to control
  cloning etc?

- make redoes everythgin when OPT

