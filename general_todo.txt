- a bit odd to have both mac_recv_l{2,3}_pkt in agents, no?
  in a way do we expect that an agent *has* to only implement one?
  should we put default null methods in rt_agent_base???
  
- magic_bler_agent: merge into GREASE??
- note: in rewriting , reorging lots of stuff, never sure whether should have
  explicit class type, just a .mli with the class (but not the type), etc.
  maybe emerging "rule" is to only have class types for things which have
  multiple implementations (world, agent, mac, etc).

- taurus:
  what needs to change?
  a) Crworld methods from world.mli:
     world.boundarize
     world.dist_coords
     world.are_neighbors

     Crworld 'internal' methods:
     grid_neighbors_ 
     get_nodes_in_ring  ** 


  b) Crsearch.xsect_grid_and_circle **
    

  c) Mobility processes

  ** these are only used when calling 'find_closest_node' - so should be able
     to first do the rest, and test in grep.



- time type and funs from common.ml should go in their own file 

- think about file reorg.

  mws/
  mws/types/
  mws/core/
  mws/pkt/
  mws/mob/
  gui/    (? or does gui go under mws ?)
  
  lib/
  lib/ext (stuff from other people)

  maybe only core things (like sched, world, and base classes for mac, agent,
  mob) go in mws. 
  then would we have one 'agents' dir for all agents, and one 'mac' dir for
  all macs, etc?

  maybe better is to have the core dirs (like pkt/ mws/ ) be horizontal, in
  that they cut across different functional aspects, but then there should be
  'vertical' per-protocol directories? 'vertical' in the sens that a 'grep'
  directory would contain grep agents, and also grep scripts?
  but then this poses a problem for common scripts (to run tests against both)
  or common code (like a base class for both aodv and grep).
  need to think. 

  for sure, directory structure should be more "readable" for a newbie.
  maybe it makes sense to have a "types" dir (like interfaces/ in tinyos)?
  i like that idea.
  the types to be transferred would include:
  world.ml (kill .mli)
  rt_agent.ml (kill .mli)

  mob.mli (need some work to split things out)
  sched.mli (need to split out sched interface from implementation, in same 
  way as rt_agent vs rt_agent_base ???)
  type nodeid_t from common.ml

- make all target:
  have a target that builds all scripts, so that we make sure not to break a
  the build for "old" scripts. 
  started doing this. need to figure out a clean way to build for all scripts
  in a list, rather than have to make an explicit target in teh makefile for
  each one.
  hand-tested diffusion_example.ml; doesn't work - need to revive
  make_gpsnodes in script_utils.ml, should probably find this in cvs.
	
- persistency: 
  not really figured out if restoring nodes should make us delete node objects,
  and then recreate them (along with any mob, mac, agent, .. objects; this would
  require a way to specify what such objects must be created for each node)
  or simply as currently.
  Decided to keep things as are for now. this is not a definite solution, but
  it makes more sense to try to come up with a full solution when i'll be
  faced with the need for it (and will thus better understand what the needs
  are).


- multiple traffic sources to multiple destinations (mentioned in
 simplenode.mli, but with XXX)
- consider the use of named function parameters. maybe going overboard with
 the ~s right now. maybe not, but at least need to be consistent.
 one criteria could be: 
 + when there is no .mli, and there are not multiple args of same type, then no
 need for ~ (properly naming the parameter is enough)
 + when there is a .mli, same as above, except that if parameter is of a generic
 type, (like int), then possible name the parameter.
 One the other hand, if parameter is say a L3pkt.t, then naming it ~l3pkt does
 not really help a lot.
 + when there are multiple parameters with same type, then definitely ~ helps.

- add copyright. not to heap, opt, and probably some others
/bin/sed-4.07  -i -e 's/(\*                                  \*)//g' simplenode.mli 
/bin/sed-4.07 -i  -e 's/(\* mws  multihop wireless simulator \*)//g' simplenode.mli 

- crworld.is_connected: 
  should be more efficient to originate one flood from one point, and see if
  everyone gets it. 
-  should clean up read_coords/epflcoords. 
   probably wait till a new dataset comes in (from michal?) and at that point,
   figure out the proper interfaces, abstractions, etc.

- mhooks : when you replace an array of agents with new ones, the old ones
  don't go away because they are still hooked in to their owners...
  one possibility would be to have add_*_hook methods return a handle (for
  example hooks are kept in a hash), and then a diff_Agent (or anyone else who
  has a handle) can have a detach() method which kills all its hooks before
  dying. 
  
- config: 
  val make_cmdline_able : 'a t -> unit
  val make_not_cmdline_able : 'a t -> unit

- creating nodes in script_utils
  there are going to be an increasing # of possible configurations, ie all 
  possible combinations of agents, MACs, etc.
  So instead of having one explicit function for each one (make_grease_nodes,
  make_grep_nodes, etc), we should have a more generic way of doing it.

  One possible solution:maybe a make_nodes(), then a make_*_agent which makes * type agents and adds
  them, similarly for macs, etc. Then we have a # of make funs which is linear
  in the # of different agents/macs/nodes rather than the comb. explosion of
  all combinations.

  Another possible solution: all these choosable things (which MAC, which
  diffusion algo, which routing agent) are settable by Params. Then there is
  only one "make_macs" which makes them based on what the Param value is.
  
- a big question is coming back all the time about how/where to access
  objects. For example, i make many hello_agents. Are these kept in an array
  in the same file as the hello_Agent class? in the script file? this impacts
  then routings like proportion_met_nodes(), etc..

- time printing in sched should use log. but this made a headache for circular
  dependency...

- neighbors: right now, seems like a node has itself as a neighbor. is this
  necessary? seems not. check well before changing...

- clean up mobility :
  granularity needs to be solidified. IF it is going to be used, then shoudl
  be tweakable. Also how does it relate to say random walk processes. Do they
  simply ignore it? Or do we distinguish between 'continuous' and 'discrete'
  classes?

  
- think about order in which mhooks is invoked. it can matter, in the case
  where agent code modifies packet. f. ex in ease_agent, if anchor changes in
  last hop, then we get:
  hop:<2865.353, 2561.326> 	anchor:<2970.990, 2469.370> 	age:8.000000 	cost:0.000000
  hop:<2918.412, 2582.598> 	anchor:<2970.990, 2469.370> 	age:8.000000 	cost:0.000000
  hop:<2989.889, 2587.548> 	anchor:<2970.990, 2469.370> 	age:8.000000 	cost:0.000000
  hop:<2949.183, 2459.140> 	anchor:<2951.178, 2434.621> 	age:0.000000 	cost:24.599721
  hop:<2951.178, 2434.621> 	anchor:<2951.178, 2434.621> 	age:0.000000 	cost:24.599721
  Fatal error: exception Failure("Searchcost was non-zero without anchor change")

- packets: better, but still somewhat unhappy with the type.
  maybe the union of all possible packet types forms a tree, and packet is a
  path through that tree (ie, a list of headers)?? might be better for typing.
  might make all these recursive operations (like *_clone, *_size) easier

  wishlist: 
  expressive typing:
  each packet type is fully 'expressed' in the type system, meaning that it
  has its fields and only its own. For example, a grep l3hdr should not be the
  same as an ease l3hdr
  'automatic' cloning and sizing : ideally clone and size operations could be
  recursively done on each packet type.

  get rid of mutable fields? or if we keep them, have a failsafe way to control
  cloning etc?

- make redoes everythgin when OPT

