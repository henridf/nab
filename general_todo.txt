- think about file reorg.
  maybe only core things (like sched, world, and base classes for mac, agent,
  mob) go in mws. 
  then would we have one 'agents' dir for all agents, and one 'mac' dir for
  all macs, etc?

  maybe better is to have the core dirs (like pkt/ mws/ ) be horizontal, in
  that they cut across different functional aspects, but then there should be
  'vertical' per-protocol directories? 'vertical' in the sens that a 'grep'
  directory would contain grep agents, and also grep scripts?
  but then this poses a problem for common scripts (to run tests against both)
  or common code (like a base class for both aodv and grep).
  need to think. 


- multiple traffic sources to multiple destinations (mentioned in
 simplenode.mli, but with XXX)
- consider the use of named function parameters. maybe going overboard with
 the ~s right now. maybe not, but at least need to be consistent.
 one criteria could be: 
 + when there is no .mli, and there are not multiple args of same type, then no
 need for ~ (properly naming the parameter is enough)
 + when there is a .mli, same as above, except that if parameter is of a generic
 type, (like int), then possible name the parameter.
 One the other hand, if parameter is say a L3pkt.t, then naming it ~l3pkt does
 not really help a lot.
 + when there are multiple parameters with same type, then definitely ~ helps.

- add copyright. not to heap, opt, and probably some others
/bin/sed-4.07  -i -e 's/(\*                                  \*)//g' simplenode.mli 
/bin/sed-4.07 -i  -e 's/(\* mws  multihop wireless simulator \*)//g' simplenode.mli 
- (idea) in mods.ml, add stg like Module List = ListLabels, etc, for other
  labelled modules. Then need to modify code, for all list iterations we would
  then be able to put list before function for example.
- crworld.is_connected: 
  should be more efficient to originate one flood from one point, and see if
  everyone gets it. 
-  mob.ml is tied in an ugly manner to pixels, epflcoords, etc, which obliges
    things like:
    (a) have epflcoords and readcoords in mws_object_files in makefile
    (b) replicate pix/mtr conversion functions in mob.ml

    need to break this somehow.
    this will also allow putting the params.x/y_pix_size into mwsconv.ml,
    where they belong

    actually it's not clear that (a) is really bad.
    for (b), the root of the problem seems to be that epflcoords is
    represented in pixels. one approach would be to convert it to meters.

- mhooks : when you replace an array of agents with new ones, the old ones
  don't go away because they are still hooked in to their owners...
  one possibility would be to have add_*_hook methods return a handle (for
  example hooks are kept in a hash), and then a diff_Agent (or anyone else who
  has a handle) can have a detach() method which kills all its hooks before
  dying. 
  
- config: 
  val make_cmdline_able : 'a t -> unit
  val make_not_cmdline_able : 'a t -> unit

- creating nodes in script_utils
  there are going to be an increasing # of possible configurations, ie all 
  possible combinations of agents, MACs, etc.
  So instead of having one explicit function for each one (make_grease_nodes,
  make_grep_nodes, etc), we should have a more generic way of doing it.

  One possible solution:maybe a make_nodes(), then a make_*_agent which makes * type agents and adds
  them, similarly for macs, etc. Then we have a # of make funs which is linear
  in the # of different agents/macs/nodes rather than the comb. explosion of
  all combinations.

  Another possible solution: all these choosable things (which MAC, which
  diffusion algo, which routing agent) are settable by Params. Then there is
  only one "make_macs" which makes them based on what the Param value is.
  
- a big question is coming back all the time about how/where to access
  objects. For example, i make many hello_agents. Are these kept in an array
  in the same file as the hello_Agent class? in the script file? this impacts
  then routings like proportion_met_nodes(), etc..

- time printing in sched should use log. but this made a headache for circular
  dependency...

- neighbors: right now, seems like a node has itself as a neighbor. is this
  necessary? seems not. check well before changing...

- clean up mobility :
  granularity needs to be solidified. IF it is going to be used, then shoudl
  be tweakable. Also how does it relate to say random walk processes. Do they
  simply ignore it? Or do we distinguish between 'continuous' and 'discrete'
  classes?

  
- think about order in which mhooks is invoked. it can matter, in the case
  where agent code modifies packet. f. ex in ease_agent, if anchor changes in
  last hop, then we get:
  hop:<2865.353, 2561.326> 	anchor:<2970.990, 2469.370> 	age:8.000000 	cost:0.000000
  hop:<2918.412, 2582.598> 	anchor:<2970.990, 2469.370> 	age:8.000000 	cost:0.000000
  hop:<2989.889, 2587.548> 	anchor:<2970.990, 2469.370> 	age:8.000000 	cost:0.000000
  hop:<2949.183, 2459.140> 	anchor:<2951.178, 2434.621> 	age:0.000000 	cost:24.599721
  hop:<2951.178, 2434.621> 	anchor:<2951.178, 2434.621> 	age:0.000000 	cost:24.599721
  Fatal error: exception Failure("Searchcost was non-zero without anchor change")

- packets: better, but still somewhat unhappy with the type.
  maybe the union of all possible packet types forms a tree, and packet is a
  path through that tree (ie, a list of headers)?? might be better for typing.
  might make all these recursive operations (like *_clone, *_size) easier

  wishlist: 
  expressive typing:
  each packet type is fully 'expressed' in the type system, meaning that it
  has its fields and only its own. For example, a grep l3hdr should not be the
  same as an ease l3hdr
  'automatic' cloning and sizing : ideally clone and size operations could be
  recursively done on each packet type.

  get rid of mutable fields? or if we keep them, have a failsafe way to control
  cloning etc?

- make redoes everythgin when OPT

